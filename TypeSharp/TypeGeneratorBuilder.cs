using NStandard;
using NStandard.Caching;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace TypeSharp
{
    public class TypeScriptModelBuilder
    {
        public static readonly TsType TsNumberType = new TsType { TypeName = "number" };
        public static readonly TsType TsBooleanType = new TsType { TypeName = "boolean" };
        public static readonly TsType TsAnyType = new TsType { TypeName = "any" };
        public static readonly TsType TsStringType = new TsType { TypeName = "string" };
        public static readonly TsType TsDateType = new TsType { TypeName = "Date" };

        public CacheContainer<Type, TsType> TsTypes { get; private set; }

        public TypeScriptModelBuilder()
        {
            TsTypes = new CacheContainer<Type, TsType>
            {
                CacheMethod = type =>
                {
                    return new CacheDelegate<TsType>(() =>
                    {
                        switch (type)
                        {
                            case Type _ when type == typeof(bool): return TsBooleanType;

                            case Type _ when type == typeof(string):
                            case Type _ when type == typeof(Guid): return TsStringType;

                            case Type _ when type == typeof(byte):
                            case Type _ when type == typeof(sbyte):
                            case Type _ when type == typeof(char):
                            case Type _ when type == typeof(short):
                            case Type _ when type == typeof(ushort):
                            case Type _ when type == typeof(int):
                            case Type _ when type == typeof(uint):
                            case Type _ when type == typeof(long):
                            case Type _ when type == typeof(ulong):
                            case Type _ when type == typeof(float):
                            case Type _ when type == typeof(double):
                            case Type _ when type == typeof(decimal): return TsNumberType;

                            case Type _ when type == typeof(object):
                            case Type _ when type.IsImplement(typeof(IDictionary<,>)): return TsAnyType;

                            case Type _ when type.IsImplement(typeof(IEnumerable<>)): return ParseIEnumerable(type);

                            case Type _ when type.IsClass: return ParseType(type);

                            case Type _ when type.IsType(typeof(Nullable<>)): return TsTypes[type.GenericTypeArguments[0]].Value;

                            case Type _ when type.IsEnum: return ParseEnum(type);

                            default: throw new NotSupportedException($"{type.FullName} is not supported.");
                        }
                    });
                },
            };
        }
        public Dictionary<FieldInfo, TsConst> TsConsts { get; private set; } = new Dictionary<FieldInfo, TsConst>();

        public void WriteTo(string path) => File.WriteAllText(path, Compile());

        public string Compile()
        {
            var code = new StringBuilder();
            code.AppendLine($"/* Generated by TypeSharp v{Assembly.GetExecutingAssembly().GetName().Version} */");

            #region Compile Types
            TsTypes.Values.ToArray().Each(x => x.Update());
            var typeGroup = TsTypes.Values.Select(x => x.Value).Where(x => x.Namespace != null).GroupBy(x => x.Namespace);
            if (typeGroup.Any()) code.AppendLine();
            foreach (var typeGroupItem in typeGroup)
            {
                code.AppendLine($"declare namespace {typeGroupItem.Key} {{");
                foreach (var tsType in typeGroupItem)
                {
                    switch (tsType.TypeClass)
                    {
                        case TsTypeClass.Interface:
                            code.AppendLine($"{" ".Repeat(4)}interface {tsType.TypeName} {{");
                            foreach (var tsProperty in tsType.TsProperties)
                            {
                                code.AppendLine($"{" ".Repeat(8)}{tsProperty.PropertyName}? : {tsProperty.PropertyTypeDefinition ?? tsProperty.PropertyType.ReferenceName};");
                            }
                            code.AppendLine($"{" ".Repeat(4)}}}");
                            break;

                        case TsTypeClass.Enum:
                            code.AppendLine($"{" ".Repeat(4)}export const enum {tsType.TypeName} {{");
                            foreach (var tsEnumValue in tsType.TsEnumValues)
                            {
                                code.AppendLine($"{" ".Repeat(8)}{tsEnumValue.Name} = {tsEnumValue.Value},");
                            }
                            code.AppendLine($"{" ".Repeat(4)}}}");
                            break;
                    }
                }
                code.AppendLine($"}}");
            }
            #endregion

            #region Compile Consts
            var tsConstOuterGroup = TsConsts.Values.ToArray().GroupBy(x => x.OuterNamespace);
            if (tsConstOuterGroup.Any()) code.AppendLine();
            foreach (var tsConstOuterGroupItem in tsConstOuterGroup)
            {
                var tsConstInnerGroup = tsConstOuterGroupItem.GroupBy(x => x.InnerNamespace);
                code.AppendLine($"namespace {tsConstOuterGroupItem.Key} {{");
                foreach (var tsConstInnerGroupItem in tsConstInnerGroup)
                {
                    code.AppendLine($"{" ".Repeat(4)}export namespace {tsConstInnerGroupItem.Key} {{");
                    foreach (var tsConst in tsConstInnerGroupItem)
                    {
                        code.AppendLine($"{" ".Repeat(8)}export const {tsConst.ConstName} : {tsConst.ConstType.TypeName} = {tsConst.ConstValue};");
                    }
                    code.AppendLine($"{" ".Repeat(4)}}}");
                }
                code.AppendLine($"}}");
            }
            #endregion

            return code.ToString();
        }

        private string GetTsNamespace(Type type)
        {
            var attr = type.GetCustomAttribute<TypeScriptModelAttribute>();
            if (attr?.Namespace is null)
            {
                var dType = type.DeclaringType;
                if (dType is null)
                    return type.Namespace;
                else return $"{GetTsNamespace(dType)}.{type.Name}";
            }
            else return attr.Namespace;
        }

        private TsType ParseIEnumerable(Type type)
        {
            var enumerable = type.AsInterface(typeof(IEnumerable<>));
            var elementType = enumerable.GetGenericArguments()[0];
            var tsType = TsTypes[elementType];
            return new TsType
            {
                Namespace = tsType.Value.Namespace,
                TypeName = $"{tsType.Value.TypeName}{"[]"}",
            };
        }

        private void CacheConsts(Type type)
        {
            var consts = type.GetFields().Where(x => x.IsStatic && x.IsLiteral && x.IsPublic);
            foreach (var field in consts)
            {
                TsConsts[field] = new TsConst
                {
                    OuterNamespace = GetTsNamespace(type),
                    InnerNamespace = type.Name,
                    ConstName = field.Name,
                    ConstType = TsTypes[field.FieldType].Value,
                    ConstValue = field.GetValue(null).For(v => v is string ? $"'{v}'" : v.ToString()),
                };
            }
        }

        private TsType ParseEnum(Type type)
        {
            return new TsType
            {
                Namespace = GetTsNamespace(type),
                TypeName = type.Name,
                TypeClass = TsTypeClass.Enum,
                TsEnumValues = Enum.GetNames(type).Select(name => new TsEnumValue
                {
                    Name = name,
                    Value = (int)Enum.Parse(type, name),
                }).ToArray(),
            };
        }

        private TsType ParseType(Type type)
        {
            var tsNamespace = GetTsNamespace(type);

            CacheConsts(type);

            var props = type.GetProperties();
            if (type.IsGenericType)
            {
                var pureName = type.Name.Project(new Regex(@"([^`]+)"));
                var genericTypes = type.IsGenericTypeDefinition
                    ? type.GetGenericArguments().Select(x => x.Name)
                    : type.GetGenericArguments().Select(x => TsTypes[x].Value.ReferenceName);
                var typeName = $"{pureName}<{genericTypes.Join(", ")}>";

                if (type.IsGenericTypeDefinition)
                {
                    return new TsType
                    {
                        Namespace = tsNamespace,
                        TypeName = typeName,
                        TsProperties = props.Select(prop =>
                        {
                            var propType = prop.PropertyType;
                            if (propType.IsGenericParameter)
                            {
                                return new TsProperty
                                {
                                    PropertyName = StringEx.CamelCase(prop.Name),
                                    PropertyTypeDefinition = propType.Name,
                                };
                            }
                            else
                            {
                                return new TsProperty
                                {
                                    PropertyName = StringEx.CamelCase(prop.Name),
                                    PropertyType = TsTypes[propType].Value,
                                };
                            }
                        }).ToArray()
                    };
                }
                else
                {
                    return new TsType
                    {
                        Namespace = null,
                        TypeName = typeName,
                    };
                }
            }
            else
            {
                var typeName = type.Name;
                return new TsType
                {
                    Namespace = tsNamespace,
                    TypeName = typeName,
                    TsProperties = props.Select(prop =>
                    {
                        var propType = prop.PropertyType;
                        return new TsProperty
                        {
                            PropertyName = StringEx.CamelCase(prop.Name),
                            PropertyType = TsTypes[propType].Value,
                        };
                    }).ToArray()
                };
            }
        }

        public void CacheTypes(params Type[] types) => types.Each(type => CacheType(type));
        public void CacheType<TType>() => CacheType(typeof(TType));
        public void CacheType(Type type) => _ = TsTypes[type];

    }
}